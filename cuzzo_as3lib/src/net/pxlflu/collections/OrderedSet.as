package com.atmospherebbdo.collections {	import com.atmospherebbdo.assertions.assert;	import com.atmospherebbdo.dbc.precondition;	import com.atmospherebbdo.util.IComparable;	import com.atmospherebbdo.util.array.wrapArrayCallback;	import com.atmospherebbdo.util.iComparableSort;			/**	 * @author markhawley	 * 	 * A set that maintains an order like am ordered List. It is assumed that 	 * objects in the Set either have an obvious ordering (Numbers, Strings, etc.)	 * or implement than IComparable interface.	 */ 	public class OrderedSet extends Set implements ISet	{		/**		 * Function to use when sorting this Set. If left null, the sort() method		 * will do its best to sort the set anyway.		 */		public var sortFunction:Function;				/**		 * Constructor.		 * 		 * @param array	Array to populate the collection with		 * @param type	Class, an optional type for a typed collection		 */		public function OrderedSet( array:Array=null, type:Class=null)		{			super(array, type);		}				/**		 * Adds an object to the collection. It is assumed that objects added		 * have an obvious ordering or implement the IComparable interface.		 * 		 * @param	obj	*		 * 		 * @return Boolean true on success		 */		override public function add(obj:*):Boolean		{			precondition(obj is Number || obj is String || obj is IComparable);						var success:Boolean = super.add(obj);						sort();						return success;		}				/**		 * Sorts the collection.		 * 		 * While this function is a little oversized, it does as little redundant		 * work as possible. For fine-grained control over an OrderedSet, you		 * should provide a custom sortFunction.		 */		private function sort() :void		{			if (isEmpty())			{				return;			}						var sorter:* = sortFunction;						if (!sorter)			{				// still hunting for a way to sort. If the collection is typed,				// just check the type.				var allNumeric:Boolean = valueType == Number || valueType == int || valueType == uint;				var allString:Boolean = valueType == String;				var allIComparable:Boolean = false;								// non-typed collection, have to look at all elements				if (valueType == null || (!allNumeric && !allString))				{					allNumeric = true;					allString = true;					allIComparable = true;										// disprove the above if possible...					impl.map(wrapArrayCallback(function (item:*) :void					{						// one item is false, all are false for that check						allNumeric &&= item is Number;						allString &&= item is String;						allIComparable &&= item is IComparable;						}));				}								assert( (allNumeric && allString && allIComparable) == false, 					"All elements of the set must be at most one of Number, " +					"String, or IComparable." );								if (allNumeric)				{					sorter = Array.NUMERIC;				}				else if (allString)				{					sorter = null;				}				else if (allIComparable)				{					sorter = iComparableSort;				}				else				{					sorter = null;				}			}						if (sorter)			{				impl.sort(sorter);			}			else			{				impl.sort();			}		}	}}