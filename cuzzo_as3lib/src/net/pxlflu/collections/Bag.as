package com.atmospherebbdo.collections {	import com.atmospherebbdo.collections.IBag;	import com.atmospherebbdo.errors.IllegalStateError;		/**	 * @author markhawley	 * 	 * A bag or multiset.	 */	public class Bag extends AbstractDictionaryCollection implements IBag 	{		/**		 * Constructor.		 * 		 * @param	array	Array to populate the bag with initially.		 * @param	valueType	Class, for type checking of bag entries.		 */		public function Bag( array:Array=null, valueType:Class=null )		{			super( array, valueType, uint );		}		/**		 * Returns the number of obj present in the bag.		 * 		 * @param	obj	* the item to count		 * 		 * @return int		 */		public function getCount(obj:*):int		{			var count:int = impl[obj] as int;			count = isNaN(count) ? 0 : count;			return count;		}				/**		 * Returns a set of all unique items in the bag.		 * 		 * @return	ISet		 */		public function uniqueSet():ISet		{			// in a dictionary bag, the values are always a count, and the			// key type is the 'real' value type			var uniques:ISet = new Set( getImplKeys(), keyType );			return uniques;		}				/**		 * Returns true if obj is in the collection.		 * 		 * @param	obj	*		 * 		 * @return	Boolean		 */		override public function contains(obj:*):Boolean		{			return (impl[obj] != undefined);		}				/**		 * Adds an object to the bag.		 * 		 * @param	obj	*		 * 		 * @return	Boolean, true on success		 */		override public function add(obj:*):Boolean		{			if (keyType != null && !(obj is keyType))			{				throw new TypeError("Can't add '" + obj + "' to typed " +					"collection.");			}			if (impl[obj] == undefined)			{				impl[obj] = 0;			}			impl[obj]++;			onChange();			onAdd([obj]);			return true;		}				/**		 * Removes an object from the bag.		 * 		 * @param	obj	*		 * 		 * @return	Boolean, true on success.		 */		override public function remove(obj:*):Boolean		{			if (impl[obj] == undefined)			{				return false;			}			else			{				impl[obj]--;				if (impl[obj] == 0)				{					delete impl[obj];				}				onChange();				onRemove([ obj ]);				return true;			}		}				/**		 * Returns the number of items in the bag.		 * 		 * @return	uint		 */		override public function size():uint		{			var values:Array = getImplValues();			var total:uint = 0;			for (var i:uint=0; i < values.length; i++) 			{				total += values[i];			}			return total;		}				/**		 * Returns an iterator for the collection. The default		 * iterator for Bags has no defined order.		 * 		 * @param	type	IIterationType		 * 		 * @return	IIterator		 */		override public function getIterator( type:IterationType=null ) :IIterator		{			var iterator:IIterator;						switch( type )			{				case null: // default iterator				case BagIterationType.DEFAULT:					iterator = new BagDictionaryDefaultIterator( this, impl );					break;				default:					throw new IllegalStateError("Unsupported " +						"iteration type: " + type);					break;			}						return iterator;		}				/**		 * Subtracts a bag from this bag.		 * 		 * @param	other	IBag		 * 		 * @return	IBag		 */		public function difference(other:IBag):IBag		{			var b:IBag = new Bag();						var keySet:ISet = uniqueSet().union(other.uniqueSet());			var keySetIter:IIterator = keySet.getIterator();						while(keySetIter.hasNext())			{				var key:* = keySetIter.next();				var times:uint = Math.max(0, getCount(key) - other.getCount(key));								for (var i:uint = 0; i < times; i++) 				{					b.add(key);				}			}			return b;		}				/**		 * Returns a union of this bag and another bag.		 * 		 * @param	other	IBag		 * 		 * @return IBag		 */		public function union(other:IBag):IBag		{			var b:IBag = new Bag();						var keySet:ISet = uniqueSet().union(other.uniqueSet());			var keySetIter:IIterator = keySet.getIterator();						while(keySetIter.hasNext())			{				var key:* = keySetIter.next();				var times:uint = Math.max( getCount(key), other.getCount(key));								for (var i:uint = 0; i < times; i++) 				{					b.add(key);				}			}			return b;		}				/**		 * Returns an intersection of this bag and another bag.		 * 		 * @param	other	IBag		 * 		 * @return	IBag		 */		public function intersection(other:IBag):IBag		{			var b:IBag = new Bag();						var keySet:ISet = uniqueSet().intersection(other.uniqueSet());			var keySetIter:IIterator = keySet.getIterator();						while(keySetIter.hasNext())			{				var key:* = keySetIter.next();				var times:uint = Math.min( getCount(key), other.getCount(key));								for (var i:uint = 0; i < times; i++) 				{					b.add(key);				}			}			return b;		}	}}