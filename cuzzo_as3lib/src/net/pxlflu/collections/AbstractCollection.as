package com.atmospherebbdo.collections {	import com.atmospherebbdo.collections.ICollection;	import com.atmospherebbdo.collections.IIterator;	import com.atmospherebbdo.collections.IterationType;	import com.atmospherebbdo.collections.events.CollectionEvent;	import com.atmospherebbdo.dbc.precondition;	import com.atmospherebbdo.errors.AbstractMethodCallError;	import com.atmospherebbdo.util.array.wrapArrayCallback;	import com.atmospherebbdo.util.instantiatedAs;		import flash.events.EventDispatcher;	import flash.events.IEventDispatcher;		[Event(name="CollectionEvent: Changed", type="com.atmospherebbdo.collections.events.CollectionEvent")]	[Event(name="CollectionEvent: add", type="com.atmospherebbdo.collections.events.CollectionEvent")]	[Event(name="CollectionEvent: remove", type="com.atmospherebbdo.collections.events.CollectionEvent")]	[Event(name="CollectionEvent: move", type="com.atmospherebbdo.collections.events.CollectionEvent")]	[Event(name="CollectionEvent: replace", type="com.atmospherebbdo.collections.events.CollectionEvent")]	[Event(name="CollectionEvent: reset", type="com.atmospherebbdo.collections.events.CollectionEvent")]	[Event(name="CollectionEvent: refresh", type="com.atmospherebbdo.collections.events.CollectionEvent")]	[Event(name="CollectionEvent: update", type="com.atmospherebbdo.collections.events.CollectionEvent")]		/**	 * @author markhawley	 * 	 * Abstract collection type, base of the heirarchy.	 */	internal class AbstractCollection extends EventDispatcher implements ICollection, IEventDispatcher	{			protected var valueType:Class;				/**		 * Constructor.		 * 		 * @param array	Array	(optional) to populate collection with		 * @param type	Class	(optional) for typed collection		 * 		 * @throws AbstractMethodCallError if directly instantiated.		 */		public function AbstractCollection( array:Array=null, type:Class=null)		{			if (instantiatedAs( this, AbstractCollection))			{				throw new AbstractMethodCallError("Cannot " +					"instantiate Abstract class.");			}						valueType = type;						if (array)			{				array.forEach(wrapArrayCallback(function (item:*) :void 				{					add(item);				}), this);			}		}		/**		 * Dispatches CollectionEvent.CHANGE as needed.		 */		protected function onChange() :void		{			var event:CollectionEvent = new CollectionEvent( CollectionEvent.CHANGED );			dispatchEvent(event );		}				/**		 * Dispatches CollectionEvent.ADD as needed.		 */		protected function onAdd( added:Array ) :void		{			precondition( added.length > 0);						var event:CollectionEvent = new CollectionEvent( CollectionEvent.ADD );			event.items = added;			dispatchEvent(event);		}				/**		 * Dispatches CollectionEvent.REMOVE as needed.		 */		protected function onRemove( removed:Array ) :void		{			precondition( removed.length > 0);						var event:CollectionEvent = new CollectionEvent( CollectionEvent.REMOVE );			event.items = removed;			dispatchEvent(event );		}				/**		 * Dispatches CollectionEvent.MOVE as needed.		 */		protected function onMove( items:Array, from:uint, to:uint) :void		{			trace( "items: " + items );						precondition(items.length > 0);						var event:CollectionEvent = new CollectionEvent(CollectionEvent.MOVE);			event.items = items;			event.location = to;			event.oldLocation = from;			dispatchEvent(event);		}				/**		 * Dispatches CollectionEvent.REFRESH as needed.		 */		protected function onRefresh() :void		{			var event:CollectionEvent = new CollectionEvent( CollectionEvent.REFRESH );			dispatchEvent(event );		}				/**		 * Dispatches CollectionEvent.RESET as needed.		 */		protected function onReset() :void		{			var event:CollectionEvent = new CollectionEvent( CollectionEvent.RESET );			dispatchEvent(event );		}				/**		 * Dispatches CollectionEvent.REPLACE as needed.		 */		protected function onReplace( at:uint ) :void		{			var event:CollectionEvent = new CollectionEvent( CollectionEvent.REPLACE);			event.location = at;			dispatchEvent(event );		}				/**		 * Dispatches CollectionEvent.UPDATE as needed.		 */		protected function onUpdate( updated:Array ) :void		{			var event:CollectionEvent = new CollectionEvent( CollectionEvent.UPDATE);			event.items = updated;			dispatchEvent(event );		}				/**		 *		 * 		 * @return Boolean, true if the collection is empty.		 */		public function isEmpty():Boolean		{			throw new AbstractMethodCallError();			return null;		}				/**		 * @param	obj	* item to look for in the collection		 * 		 * @return Boolean, if obj exists in the collection.		 */		public function contains(obj:*):Boolean		{			throw new AbstractMethodCallError();			return null;		}				/**		 * @param obj	* item to add.		 * 		 * @return Boolean, true on success.		 */		public function add(obj:*):Boolean		{			throw new AbstractMethodCallError();			return null;		}				/**		 * @param	obj	* item to remove.		 * 		 * @return Boolean, true on success.		 */		public function remove(obj:*):Boolean		{			throw new AbstractMethodCallError();			return null;		}				/**		 * Returns the size of the collection.		 * 		 * @return uint		 */		public function size():uint		{			throw new AbstractMethodCallError();			return 0;		}				/**		 * @param type	IterationType (optional)		 * 		 * @return IIterator		 */		public function getIterator(type:IterationType = null):IIterator		{			throw new AbstractMethodCallError();			return null;		}	}}