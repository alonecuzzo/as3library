package com.atmospherebbdo.load {	import br.com.stimuli.loading.BulkLoader;	import br.com.stimuli.loading.BulkProgressEvent;		import com.atmospherebbdo.collections.IMap;	import com.atmospherebbdo.collections.Map;	import com.atmospherebbdo.dbc.precondition;	import com.atmospherebbdo.util.IDestroyable;		import flash.display.AVM1Movie;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.MovieClip;	import flash.events.ErrorEvent;	import flash.events.EventDispatcher;	import flash.events.ProgressEvent;	import flash.media.Sound;	import flash.net.NetStream;	import flash.utils.ByteArray;			[Event(name="progress", type="com.atmospherebbdo.load.LoadProgressEvent")]	[Event(name="complete", type="com.atmospherebbdo.load.LoadProgressEvent")]	/**	 * @author markhawley	 * 	 * Loads as many items or as many types as you'd like.	 */	public class MultiLoader extends EventDispatcher implements ILoader, IDestroyable	{		private static var counter:uint = 0;				private var impl:BulkLoader;				private var _isDestroyed:Boolean = false;				/**		 * Constructor.		 */		public function MultiLoader() 		{			impl = new BulkLoader( "BULK_LOADER_"+counter++ );			impl.addEventListener(BulkProgressEvent.COMPLETE, onMultiLoadComplete);			impl.addEventListener(BulkProgressEvent.PROGRESS, onMultiLoadProgress);			impl.addEventListener(BulkLoader.ERROR, onMultiLoadError);		}				/**		 * Destructor.		 */		public function destroy() :void		{			precondition(!isDestroyed());						impl.removeEventListener(BulkProgressEvent.COMPLETE, onMultiLoadComplete);			impl.removeEventListener(BulkProgressEvent.PROGRESS, onMultiLoadProgress);			impl.removeEventListener(BulkLoader.ERROR, onMultiLoadError);			impl.removeAll();			impl = null;						_isDestroyed = true;		}				/**		 * Adds an item to load.		 * 		 * @param	loadable	LoadItemData		 */		public function add(loadable:LoadItemData):void		{			precondition(!isDestroyed());						impl.add( loadable.url, loadable );		}				/**		 * Returns the item loaded that is associated with a given LoadItemData.		 * 		 * @param	loadable	LoadItemData		 * 		 * @return ILoadData		 */		public function getLoadData(loadable:LoadItemData):ILoadData		{			precondition(!isDestroyed());						return impl.get( loadable.url ) as ILoadData;		}				/**		 * Returns the actual 'thing' loaded by a given LoadItemData.		 * 		 * @param	loadable	LoadItemData		 * 		 * @return *		 */		public function getContent(loadable:LoadItemData):*		{			precondition(!isDestroyed());						var fetched:Object = impl.getContent( loadable.url );			return fetched;		}				/**		 * Returns a Flash 8 and below SWF loaded by a given LoadItemData.		 * 		 * @param	loadItemData		 * 		 * @return AVM1Movie		 */		public function getAVM1Movie(loadable:LoadItemData):AVM1Movie		{			precondition(!isDestroyed());						return impl.getAVM1Movie(loadable.url);		}		/**		 * Returns a byte array from a binary file loaded by a given LoadItemData.		 * 		 * @param loadable	LoadItemData		 * 		 * @return ByteArray		 */		public function getBinary(loadable:LoadItemData):ByteArray		{			precondition(!isDestroyed());						return impl.getBinary(loadable.url);		}		/**		 * Returns XML loaded by a given LoadItemData.		 * 		 * @param	loadable LoadItemData		 * 		 * @return XML		 */		public function getXML(loadable:LoadItemData):XML		{			precondition(!isDestroyed());						return impl.getXML(loadable.url);		}				/**		 * Returns a string loaded by a given LoadItemData.		 * 		 * @param	loadable LoadItemData		 * 		 * @return String		 */		public function getText(loadable:LoadItemData):String		{			precondition(!isDestroyed());						return impl.getText(loadable.url);		}				/**		 * Returns a NetStream loaded by a given LoadItemData.		 * 		 * @param	loadable LoadItemData		 * 		 * @return NewStream		 */		public function getNetStream(loadable:LoadItemData):NetStream		{			precondition(!isDestroyed());						return impl.getNetStream(loadable.url);		}		/**		 * Returns a bitmap loaded by a given LoadItemData		 * 		 * @param loadable LoadItemData		 * 		 * @return	Bitmap		 */		public function getBitmap(loadable:LoadItemData):Bitmap		{			precondition(!isDestroyed());						return impl.getBitmap(loadable.url);		}				/**		 * Returns bitmap data loaded by a given LoadItemData.		 * 		 * @param	loadable	LoadItemData		 * 		 * @return BitmapData		 */		public function getBitmapData(loadable:LoadItemData):BitmapData		{			precondition(!isDestroyed());						return impl.getBitmapData(loadable.url);		}				/**		 * Returns a sound object loaded by a given LoadItemData		 * 		 * @param	loadable	LoadItemData		 * 		 * @return Sound		 */		public function getSound(loadable:LoadItemData):Sound		{			precondition(!isDestroyed());						return impl.getSound(loadable.url);		}		/**		 * Returns an AS3 MovieClip loaded by a given LoadItemData.		 * 		 * @param	loadable	LoadItemData		 * 		 * @return MovieClip		 */		public function getMovieClip(loadable:LoadItemData):MovieClip		{			precondition(!isDestroyed());						return impl.getMovieClip(loadable.url);		}		/**		 * Returns net stream metadata loaded by a given LoadItemData.		 * 		 * @param loadable	LoadItemData		 * 		 * @return Object		 */		public function getNetStreamMetaData(loadable:LoadItemData):Object		{			precondition(!isDestroyed());						return impl.getNetStreamMetaData(loadable.url);		}				/**		 * Start loading everything that's been added.		 */		public function start():void		{			precondition(!isDestroyed());						impl.start();		}				/**		 * Temporarily stop loading.		 */		public function pause():void		{			precondition(!isDestroyed());						impl.pauseAll();		}				/**		 * Resume a paused load.		 */		public function resume():void		{			precondition(!isDestroyed());						impl.resumeAll();		}				/**		 * Returns the bytes loaded by the loader.		 * 		 * @return int		 */		public function get bytesLoaded():int		{			precondition(!isDestroyed());						return impl.bytesLoaded;		}				/**		 * Returns the total bytes the loader will attempt to load.		 * 		 * @return int		 */		public function get bytesTotal():int		{			precondition(!isDestroyed());						return impl.bytesTotal;		}				/**		 * Returns an IMap of all items added to the loader.		 * 		 * @return IMap		 */		public function get contents():IMap		{			precondition(!isDestroyed());						var t:Object = impl.contents;						var map:IMap = new Map();						for (var key:String in t)			{				map.put(key, t[key]);			}						return map;		}				/**		 * Returns true if this is no longer a viable loader.		 * 		 * @return	Boolean, true if the loader is no longer viable.		 */		public function isDestroyed():Boolean		{			return _isDestroyed;		}		/**		 * Handler called when all items added have loaded.		 * 		 * @param	event	BulkProgressEvent		 */		private function onMultiLoadComplete(event:BulkProgressEvent) :void		{			precondition(!isDestroyed());						// rebroadcast as a LoadEvent			var le:LoadProgressEvent = convertBulkProgressEventToLoadEvent(event);			dispatchEvent(le);		}				/**		 * Handler called when the loader is loading.		 * 		 * @param	event	BulkProgressEvent		 */		private function onMultiLoadProgress(event:BulkProgressEvent) :void		{			precondition(!isDestroyed());						// rebroadcast as a LoadEvent			var le:LoadProgressEvent = convertBulkProgressEventToLoadEvent(event);			dispatchEvent(le);		}				/**		 * Handler called when the loader encounters a problem.		 * 		 * @param	event	ErrorEvent		 */		private function onMultiLoadError(event:ErrorEvent) :void		{			precondition(!isDestroyed());						// rebroadcast			dispatchEvent(event.clone());		}				/**		 * Converts a given BulkProgressEvent to a LoadProgressEvent.		 * 		 * @param	bpe	BulkProgressEvent		 * 		 * @return	LoadProgressEvent		 */		private function convertBulkProgressEventToLoadEvent( bpe:BulkProgressEvent ) :LoadProgressEvent		{			precondition(!isDestroyed());						var pe:LoadProgressEvent = new LoadProgressEvent( bpe.type, bpe.bubbles, bpe.cancelable );			pe.bytesTotalCurrent = bpe.bytesTotalCurrent;			pe.itemsLoaded = bpe.itemsLoaded;			pe.itemsTotal = bpe.itemsTotal;			pe.name = bpe.name;			pe.percentLoaded = bpe.percentLoaded;			pe.ratioLoaded = bpe.ratioLoaded;			pe.weightPercent = bpe.weightPercent;			pe.bytesLoaded = bpe.bytesLoaded;			pe.bytesTotal = bpe.bytesTotal;			return pe;		}	}}