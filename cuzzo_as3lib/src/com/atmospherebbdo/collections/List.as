package com.atmospherebbdo.collections {	import com.atmospherebbdo.collections.AbstractArrayCollection;	import com.atmospherebbdo.collections.IIterator;	import com.atmospherebbdo.collections.ListIterationType;	import com.atmospherebbdo.dbc.precondition;	import com.atmospherebbdo.errors.IllegalStateError;		/**	 * @author markhawley	 * 	 * An iterable list collection.	 */	public class List extends AbstractArrayCollection implements IList	{		/**		 * Constructor.		 */		public function List( array:Array=null, type:Class=null )		{			super( array, type );		}				/**		 * Returns an iterator for the collection. The default		 * iterator for Lists is ordered.		 * 		 * @param	type	IIterationType		 * 		 * @return	IIterator		 */		override public function getIterator( type:IterationType=null ) :IIterator		{			var iterator:IIterator;						switch( type )			{				case null: // default iterator				case ListIterationType.ORDERED:					iterator = new ArrayOrderedIterator( this, impl );					break;				case ListIterationType.RANDOM:					iterator = new ArrayRandomIterator( this, impl );					break;				case ListIterationType.LOOPING:					iterator = new ArrayLoopingIterator( this, impl );					break;				case ListIterationType.REVERSE:					iterator = new ArrayReverseIterator( this, impl );					break;				default:					throw new IllegalStateError("Unsupported " +						"iteration type: " + type);					break;			}						return iterator;		}				/**		 * Adds an object at the given index in the list.		 * 		 * @param obj	*		 * @param	index	int		 * 		 * @return Boolean, true if successful		 * 		 * @throws IndexOutOfBoundsError		 */		public function addAt(obj:*, index:int):Boolean		{			precondition(validIndex(index));						impl.splice( index, 0, obj );			onChange();			onAdd([obj]);			onMove(impl.slice(index+1), index, index+1);			return true;		}				/**		 * Returns an object at the given index in the list.		 * 		 * @param	index	int		 * 		 * @return * the object gotten		 * 		 * @throws IndexOutOfBoundsError		 */		public function getAt(index:int):*		{			precondition(validIndex(index));						return impl[index];		}				/**		 * Removes and returns the object at the given index in the list.		 * 		 * @param	index	int		 * 		 * @return * the object gotten		 * 		 * @throws IndexOutOfBoundsError		 */		public function removeAt(index:int):*		{			precondition(validIndex(index));						trace( "wtf impl.slice(index)= " + impl.slice(index) );						var removed:* = impl.splice( index, 1 )[0];			onChange();			onRemove([ removed ]);			onMove(impl.slice(index), index+1, index);			return removed;		}				/**		 * Replaces an object at the given index in the list.		 * 		 * @param 	obj	*		 * @param	index	int		 * 		 * @return * the object formerly at that index.		 * 		 * @throws IndexOutOfBoundsError		 */		public function setAt(obj:*, index:int):*		{			precondition(validIndex(index));						var old:* = impl[index];			impl[index] = obj;			onChange();			onReplace(index);			return old;		}				/**		 * Returns a sub list.		 * 		 * @param	from	int, start index		 * @param	to	int, end index		 * 		 * @return	IList		 * 		 * @throws IndexOutOfBoundsError		 */		public function subList(from:int, to:int):IList		{			precondition(validIndex(from));			precondition(validIndex(to));						var sub:List = new List();			for (var i:int = from; i < to; i++)			{				sub.add(impl[i]);			}			return sub;		}				/**		 * Returns a list iterator over the list.		 * 		 * @param type	IterationType, optional		 * 		 * @return	IListIterator		 * 		 * @throws IndexOutOfBoundsError		 */		public function getListIterator(type:IterationType = null):IListIterator		{			var iterator:IListIterator;						switch( type )			{				case null: // default iterator				case ListIterationType.ORDERED:					iterator = new ListArrayOrderedIterator( this, impl );					break;				case ListIterationType.RANDOM:					iterator = new ListArrayRandomIterator( this, impl );					break;				case ListIterationType.LOOPING:					iterator = new ListArrayLoopingIterator( this, impl );					break;				case ListIterationType.REVERSE:					iterator = new ListArrayReverseIterator( this, impl );					break;				default:					throw new IllegalStateError("Unsupported " +						"iteration type: " + type);					break;			}						return iterator;		}				/**		 * Returns false if the index is not found within the impl		 * array.		 * 		 * @param index		 * 		 * @return Boolean		 */		private function validIndex( index:int ) :Boolean		{			return !(index < 0 || index >= size());		}								public function getImplementation() :Array		{			return impl;		}	}}