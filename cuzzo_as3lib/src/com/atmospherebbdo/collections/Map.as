package com.atmospherebbdo.collections {	import com.atmospherebbdo.collections.ISet;		import flash.utils.Dictionary;		/**	 * @author markhawley	 * 	 * A Map collection -- a Dictionary-like collection class.	 */	public class Map implements IMap	{		internal var impl:Dictionary;				protected var keyType:Class;		protected var valueType:Class;				/**		 * Constructor.		 * 		 * @param	obj	* (optional) likely a dictionary to use		 * @param	kType	Class	(optional) the Class of keys to expect		 * @param	valueType	Class (optional) the Class of values to expect		 */		public function Map(obj:*=null, kType:Class=null, valueType:Class=null)		{			keyType = kType;			this.valueType = valueType;						if (obj is Dictionary)			{				impl = obj as Dictionary;			}			else			{				impl = new Dictionary();				if (obj)				{					for (var i:String in obj)					{						put( i, obj[i]);					}				}			}		}				/**		 * Returns true if a given key is present.		 * 		 * @param	key	*		 * 		 * @return Boolean, true if found		 */		public function containsKey(key:*):Boolean		{			var keys:ISet = keySet();			return keys.contains(key);		}				/**		 * Returns true if a given value is present.		 * 		 * @param	value *		 * 		 * @return Boolean, true if found		 */		public function containsValue(value:*):Boolean		{			var values:IList = values();			return values.contains(value);		}				/**		 * Returns an ISet of MapEntries for everything in the map.		 * 		 * @return	ISet of MapEntry objects.		 */		public function entrySet():ISet		{			var pairs:ISet = new Set( null, MapEntry );			for (var k:* in impl)			{				pairs.add( new MapEntry( k, impl[k]));			}			return pairs;		}				/**		 * Returns the value with the given key.		 * 		 * @param	key *		 * 		 * @return * (undefined if not found)		 */		public function getAt(key:*):*		{			return impl[key];		}				/**		 * Returns a set of all keys in the map.		 * 		 * @return ISet		 */		public function keySet():ISet		{			var keys:ISet = new Set( null, keyType );			for (var k:* in impl)			{				keys.add( k );			}			return keys;		}				/**		 * Adds a key/value pair to the map, returning the value replaced if		 * a value was already assigned to that key.		 * 		 * @param	key	*		 * @param	value *		 * 		 * @return *		 */		public function put(key:*, value:*):*		{			if (keyType != null && !(key is keyType))			{				throw new TypeError("Cannot put key '" + key + "' into " + 					"map: bad type.");			}			if (valueType != null && !(value is valueType))			{				throw new TypeError("Cannot put value '" + value + "' into " + 					"map: bad type.");			}						var old:* = getAt(key);			impl[key] = value;			return old;		}				/**		 * Returns an IList of all values present in the map.		 * 		 * @return	IList		 */		public function values():IList		{			var vals:IList = new List( null, valueType );			for (var k:* in impl)			{				vals.add( impl[k] );			}			return vals;		}				/**		 * Returns the number of entries in the map.		 * 		 * @return	int		 */		public function size():int		{			return keySet().size( );		}				/**		 * Returns true if no entries are in the map.		 * 		 * @return Boolean		 */		public function isEmpty():Boolean		{			return size() != 0;		}	}}