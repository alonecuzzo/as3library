package com.atmospherebbdo.collections {	import com.atmospherebbdo.collections.AbstractCollection;
	import com.atmospherebbdo.collections.AbstractDictionaryIterator;
	import com.atmospherebbdo.collections.IBag;
	import com.atmospherebbdo.collections.IIterator;
	import com.atmospherebbdo.collections.events.CollectionEvent;
	import com.atmospherebbdo.dbc.precondition;
	import com.atmospherebbdo.errors.NoSuchElementError;
	
	import flash.utils.Dictionary;	
	/**	 * @author markhawley	 * 	 * Default Bag iterator: returns each item in an undefined order.	 */	public class BagDictionaryDefaultIterator extends AbstractDictionaryIterator implements IIterator 	{		private var count:int = 0;		private var uniquesIterator:IIterator;		private var currentUnique:*;		private var bag:IBag;		/**		 * Constructor.		 * 		 * @param	collection	AbstractCollection		 * @param	implementation	Dictionary		 */		public function BagDictionaryDefaultIterator( collection:AbstractCollection, implementation:Dictionary )		{			precondition( collection is IBag );						super( collection, implementation );						bag = collection as IBag;			uniquesIterator = bag.uniqueSet().getIterator( );						reset();		}		/**		 * Returns true as long as the collection is not empty and		 * there is an element following the current one.		 * 		 * @return Boolean		 */		public function hasNext():Boolean		{			precondition(!invalid, "Invalid iteration over a changed collection.");						if (collection.isEmpty())			{				return false;			}						// we either don't have a unique yet, or used up the current one			if (count == bag.getCount(currentUnique))			{				// do we have a next unique key?				if (uniquesIterator.hasNext())				{					return true;				}				else				{					return false;				}			}			else			{				return true;			}		}				/**		 * Returns the next element in the collection.		 */		public function next():*		{			precondition(!invalid, "Invalid iteration over a changed collection.");						if (!hasNext())			{				throw new NoSuchElementError();			}						if (count == bag.getCount(currentUnique))			{				currentUnique = uniquesIterator.next();				count = 0;			}						count++;			return currentUnique;		}				/**		 * Handles CollectionEvent.CHANGE on iterated collection by marking the		 * iterator invalid.		 * 		 * @param	event	CollectionEvent		 */		override protected function onCollectionChange( event:CollectionEvent ) :void		{			invalid = true;		}				public function reset():void		{			if (uniquesIterator.hasNext())			{				currentUnique = uniquesIterator.next();			}			count = 0;			invalid = false;		}	}}