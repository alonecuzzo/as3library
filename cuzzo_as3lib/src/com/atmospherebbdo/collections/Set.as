package com.atmospherebbdo.collections {	import com.atmospherebbdo.collections.ISet;	import com.atmospherebbdo.dbc.postcondition;	import com.atmospherebbdo.errors.IllegalStateError;		/**	 * @author markhawley	 * 	 * An iterable set collection. 	 */	public class Set extends AbstractArrayCollection implements ISet	{		/**		 * Constructor.		 */		public function Set( array:Array=null, type:Class=null )		{			super( array, type );		}				/**		 * Adds an item to the collection. Returns true if successful.		 * 		 * @param	obj	*		 * 		 * @return	Boolean		 */		override public function add(obj:*):Boolean		{			var addedItem:Boolean = false;					if (contains(obj))			{				addedItem = false;			}			else			{				addedItem = super.add(obj);			}						postcondition( impl.length >= 1 );			postcondition( impl.indexOf(obj) == impl.lastIndexOf(obj),				"Only one instance of an object allowed in a Set." );						return addedItem;		}				/**		 * Returns an iterator for the collection. The default		 * iterator for Sets is ordered.		 * 		 * @param	type	IIterationType		 * 		 * @return	IIterator		 */		override public function getIterator( type:IterationType=null ) :IIterator		{			var iterator:IIterator;						switch( type )			{				case null: // default iterator				case SetIterationType.DEFAULT:					iterator = new ArrayOrderedIterator( this, impl );					break;				case SetIterationType.REVERSED:					iterator = new ArrayReverseIterator( this, impl );					break;				default:					throw new IllegalStateError("Unsupported " +						"iteration type: " + type);					break;			}						return iterator;		}				/**		 * Returns an ISet containing the set union of this and another set.		 * 		 * @param	other	ISet		 * 		 * @return ISet		 */		public function union( other:ISet ) :ISet		{			var iter:IIterator = other.getIterator();			var s:Set = new Set( impl );						while( iter.hasNext() )			{				s.add( iter.next() );			}						return s;		}				/**		 * Returns an ISet containing the set intersection of this and 		 * another set.		 * 		 * @param	other	ISet		 * 		 * @return ISet		 */		public function intersection( other:ISet ) :ISet		{			var s:Set = new Set();			for each (var item:* in impl) 			{				if (other.contains( item ))				{					s.add(item);					}			}			return s;		}				/**		 * Returns an ISet containing the set difference of this and another		 * set.		 * 		 * @param	other	ISet		 * 		 * @return ISet		 */		public function difference( other:ISet ) :ISet		{			var s:Set = new Set();			for each (var item:* in impl) 			{				if (!other.contains( item ))				{					s.add(item);					}			}			return s;		}	}}