package com.atmospherebbdo.util {	import com.atmospherebbdo.dbc.precondition;		/**	 * @author markhawley	 * 	 * Represents a range of items, from start to end. A little like a simple 	 * collection, a little like an automatically populated array, it's kinda 	 * like ranges in Ruby or Perl.	 */	public class Range	{		/**		 * Passed as the 3rd argument to the constructor if the end of the range		 * should not be included. Note that this is the default behavior.		 */		public static const EXCLUSIVE:Boolean = false;		/**		 * Passed as the 3rd argument to the constructor if the end of the range		 * should be included in it.		 */		public static const INCLUSIVE:Boolean = true;				private var first:*;		private var last:*;				protected var _type:Class;		/**		 * Constructor.		 * 		 * @param	start	*, a number, string, IComparable, or object defining		 * 					a next() method.		 * @param	end		*, a number, string, IComparable, or object defining		 * 					a next() method. end must be greater than (or equal 		 * 					to, if inclusive is true) start, whatever that means 		 * 					for the object passed in.		 * @param inclusive	Boolean, if true, the end value is included in the		 * 					range.		 */		public function Range( start:*, end:*, inclusive:Boolean = false )		{			// type checking...			if (start is Number)			{				precondition(end is Number, "If start is a number, end must be also.");								_type = Number;								if (!inclusive)				{					precondition(start < end, "Start must be less than end in an exclusive range.");				}				else				{					precondition(start <= end, "Start must be less than or equal to end in an inclusive range.");				}			}			else if (start is String)			{				precondition(end is String);								_type = String;								if (!inclusive)				{					precondition(start.charCodeAt(start.length - 1) < end.charCodeAt(end.length - 1));				}				else				{					precondition(start.charCodeAt(start.length - 1) <= end.charCodeAt(end.length - 1));				}			}			else if (start is IComparable)			{				precondition(end is IComparable);								_type = IComparable;								if (!inclusive)				{					precondition(start.lessThan(end));				}				else				{					precondition(start.lessThan(end) || start.equals(end));				}			}			else if (end is IOrderable)			{				_type = IOrderable;							}			else			{				precondition(end.next != undefined && end.previous != undefined);								_type = Object;			}						first = start;			last = (inclusive ? end : previous(end));		}				/**		 * Returns the smallest element of the range.		 * 		 * @return *		 */		public function get minimum() :*		{			return first;		}				/**		 * Returns the largest element of the range.		 * 		 * @return *		 */		public function get maximum() :*		{			return last;		}				public function get type() :*		{			return _type;		}		/**		 * Calls the given function, mapping each element of the range to it.		 * 		 * @param	func	Function taking one argument		 * 		 * @return	Array of all results		 */		public function map( func:Function ):Array		{			var tooFar:* = next(last);			var curr:* = first;			var results:Array = [];						while( curr != tooFar )			{				results.push(func(curr)); 				curr = next(curr);			}			return results;		}		/**		 * Acts as map(), but discards all results.		 * 		 * @param	func	Function taking one argument		 */		public function each( func:Function ):void		{			map(func);		}		/**		 * Returns an array containing every element within the range.		 * 		 * @return Array		 */		public function toArray():Array		{			return map(function (v:*) :*			{				return v;			});		}		/**		 * Returns the previous element of the range.		 * 		 * @param	v	* (see constructor for restrictions)		 * 		 * @return *		 */		private function previous( v:* ):*		{			if (v is Number)			{				return v - 1;			}			if (v is String)			{				var chars:Array = v.split();				chars[length - 1] = String.fromCharCode(chars[length - 1].charCodeAt(0) - 1);				v = chars.join("");				return v;			}			if (v.previous)			{				return v.previous();			}						throw new RangeError("No way to determine next value in range.");		}		/**		 * Returns the next element of the range.		 * 		 * @param	v	* (see constructor for restrictions)		 * 		 * @return *		 */		private function next( v:* ):*		{			if (v is Number)			{				return v + 1;			}			if (v is String)			{				var chars:Array = v.split();				chars[length - 1] = String.fromCharCode(chars[length - 1].charCodeAt(0) + 1);				v = chars.join("");				return v;			}			if (v.next)			{				return v.next();			}						throw new RangeError("No way to determine next value in range.");		}	}}