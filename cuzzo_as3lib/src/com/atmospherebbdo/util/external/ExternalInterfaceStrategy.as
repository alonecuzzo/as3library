package com.atmospherebbdo.util.external {	import com.atmospherebbdo.util.external.IExternalCommunicationStrategy;		import flash.events.TimerEvent;	import flash.external.ExternalInterface;	import flash.utils.Timer;	import flash.utils.getTimer;		/**	 * @author Mark Hawley, adapted from GAIA framework	 * 	 * Handles communication with ExternalInterface, taking into	 * account problems with closely-packed calls.	 */	public class ExternalInterfaceStrategy implements IExternalCommunicationStrategy 	{		// minimum milliseconds between calls		private static const QUEUE_WAIT:Number = 50;				private static var queue:Array = [];		private static var timer:Timer = new Timer(QUEUE_WAIT);		private static var lastCallTime:Number = -1 * QUEUE_WAIT;				/**		 * IExternalCommunicationStrategy method for communicating with the outside		 * world.		 * 		 * @param	...rest	Arguments for ExternalInterface.		 */		public function call(...rest):void		{			var obj:Object = {args:rest};						// no need to wait? fire immediately			if (queue.length == 0 && timeSinceLastCall >= QUEUE_WAIT)			{				performCall( obj );			}			else			{				addToQueue(obj);			}		}				/**		 * Enqueues an ExternalInterface call (since multiple calls right on the 		 * heels of each other cause problems.)		 * 		 * @param	obj	Object with args property, an array.		 */		private static function addToQueue(obj:Object):void 		{			if (queue.length == 0) 			{				timer.addEventListener(TimerEvent.TIMER, ExternalInterfaceStrategy.executeNext);				timer.start();			}			queue.push(obj);		}				/**		 * Taken from GAIA framework. Removes calls from the queue 		 * every half-second and sends them to ExternalInterface.		 * 		 * @param	event	TimerEvent		 */		private static function executeNext(event:TimerEvent):void 		{			if (queue.length == 0) 			{				timer.reset();				timer.removeEventListener(TimerEvent.TIMER, ExternalInterfaceStrategy.executeNext);			}			else			{				performCall( queue.shift() );			}		}				/**		 * Immediately performs a JavaScript call.		 * 		 * @param	obj	Object with args property, an array		 */		private static function performCall( obj:Object ) :void		{			if (!ExternalInterface.available)			{				trace("\n\nNOTE: ExternalInterface not available.\n\n");				return;			}						ExternalInterface.call.apply(ExternalInterface, obj.args.toString().split(","));			lastCallTime = getTimer();		}				/**		 * Returns the time since the last call to the external		 * interface.		 * 		 * @return Number		 */		private static function get timeSinceLastCall() :Number		{			return getTimer() - lastCallTime;		}				/**		 * Registers an actionscript function so it may be called from the outside		 * world.		 * 		 * @param	externalFunctionName	String		 * @param	internalFunction	Function		 */		public function addCallback(externalFunctionName:String, internalFunction:Function):void		{			ExternalInterface.addCallback(externalFunctionName, internalFunction);		}	}}